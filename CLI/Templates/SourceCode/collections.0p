use std;

__COLLECTIONS_IMPL__ = () => {

	// Linked list implementation
	// A dynamic data structure that stores elements as nodes in a structure resembling a chain.
	//
	LinkedList = () => {

		__length = 0;
		__root = void;
		__head = void;

		_Node = (value) => {
			return {
				value = value,
				next = void
			};
		};

		_Enumerator = (startNode) => {
			current = startNode;
			skip = true;
			return {
				next = () => {
					b = void;
					// Has reached end?
					if (current == void) {
						b = false;
					}
					// First call should not update value of current
					else if (skip) {
						skip = false;
						b = true;
					}
					else {
						current = current.next;
						b = current != void;
					}
					return b;
				},

				current = () => {
					return current.value;
				},

				dispose = () => { }
			};
		};

		// Adds provided value to the end of the chain
		//
		add = (e) => {
			if (__length == 0) {
				n = _Node(e);
				__root = n;
				__head = n;
			}
			else {
				n = _Node(e);
				__head.next = n;
				__head = n;
			}
			__length += 1;
		};

		// Inserts provided value as a node at 
		// provided index pushing existing node to the right
		//
		insertAt = (index, e) => {
			if (index < 0 || index > __length) {
				throw "LinkedList.insertAt: Index out of bounds";
			}
			if (index == 0) {
				node = _Node(e);
				node.next = __root;
				__root = node;
			}
			else if (index == __length) {
				n = _Node(e);
				__head.next = n;
				__head = n;
			}
			else {
				i = 1;
				previous = __root;
				current = previous.next;
				while (i < index) {
					previous = current;
					current = current.next;
					i += 1;
				}
				
				node = _Node(e);
				node.next = current;
				previous.next = node;
			}
			__length += 1;
		};

		// TODO: Implement O(1) when removing head node
		// Removes and returns value of node at provided index
		//
		removeAt = (index) => {
			if (index < 0 || index > __length - 1) {
				throw "LinkedList.removeAt: Index out of bounds";
			}

			e = void;
			if (index == 0) {
				e = __root.value;
				__root = __root.next;
			}
			else {
				i = 1;
				previous = __root;
				current = previous.next;
				while (i < index) {
					previous = current;
					current = current.next;
					i += 1;
				}

				e = current.value;
				
				// If current node is last
				if (i == __length) {
					previous.next = void;
				}
				else {
					n = current.next;
					previous.next = n;
				}
			}

			__length -= 1;

			return e;
		};

		// Removes a node from chain whose value is strictly equal to the value 
		// of the provided argument.
		// Returns true if the node was found and removed, otherwise
		// returns false.
		//
		remove = (e) => {
			previous = void;
			current = __root;
			found = false;

			// First value is e
			if (current.value === e) {
				if (current.next === void) {
					__root = void;
				}
				else {
					n = current.next;
					__root = n;
				}
			}
			else {
				previous = current;
				current = current.next;
				while (current !== void && !found) {
					if (current.value === e) {
						found = true;
					}
					else {
						previous = current;
						current = current.next;
					}
				}

				if (found) {
					if (current.next === void) {
						previous.next = void;
					}
					else {
						n = current.next;
						previous.next = n;
					}
				}
			}

			if (found) {
				__length -= 1;
			}

			return found;
		};

		// Returns the value of a node at provided index
		//
		get = (index) => {
			if (index < 0 || index > __length - 1) {
				throw "LinkedList.get: Index out of bounds";
			}
			
			e = void;
			if (index == 0) {
				e = __root.value;
			}
			else if (index == __length - 1) {
				e = __head.value;
			}
			else {
				i = 0;
				n = __root;
				while (i < index) {
					n = n.next;
					i += 1;
				}
				e = n.value;
			}

			return e;
		};

		// Updates value of an existing node
		//
		set = (index, value) => {
			if (index < 0 || index > __length - 1) {
				throw "LinkedList.set: Index out of bounds";
			}

			e = void;
			if (index == 0) {
				e = __root;
			}
			else if (index == __length - 1) {
				e = __head;
			}
			else {
				i = 0;
				n = __root;
				while (i < index) {
					n = n.next;
					i += 1;
				}
				e = n;
			}

			e.value = value;
		};

		// Returns true if the chain contains a node whose value is strictly equal
		// to the value provided as an argument
		//
		contains = (e) => {
			found = false;

			if (__length > 0) {
				if (__root.value === e) {
					found = true;
				}
				else {
					i = 0;
					n = __root;
					while (i < __length && !found) {
						if (n.value === e) {
							found = true;
						}
						else {
							n = n.next;
							i += 1;
						}
					}
				}
			}

			return found;
		};

		// Returns the node count of the chain
		//
		length = () => {
			return __length;
		};

		// Creates an returns an enumerator that iterates through the chain
		//
		enumerator = () => {
			return _Enumerator(__root);
		};

		// Returns a reference to this list
		//
		toList = () => {
			return this;
		};

		// This overload should be called by classes that implement LinkedList
		toString = callerList => {
			sb = "[";
			if (__length > 0) {
				e = _Enumerator(__root);
				i = 0;
				while (e.next()) {
					current = e.current();
					if (current === callerList) {
						sb += "<this list>";
					}
					else if (std.isStringObject(current)) {
						sb += ('"' + std.escapeSpecialCharacters(current) + '"');
					}
					else {
						sb += current;
					}

					if (i != __length - 1) {
						sb += ',';
					}
					i += 1;
				}
			}
			sb += "]";
			return sb;
		};

		toString += () => toString(this);

		this = {
			add = add,
			insertAt = insertAt,
			removeAt = removeAt,
			remove = remove,
			get = get,
			set = set,
			contains = contains,
			length = length,
			enumerator = enumerator,
			toList = toList,

			// Overrides / Overloads
			toString = toString,

			indexer [index] => get(index),

			indexer [index]<-value => {
				set(index, value);
			},
			
			// Adds element to list
			//
			operator ref[+]element => {
				ref.add(element);
				return this;
			},

			// Removes provided element from the list. Throws exception
			// if not found.
			//
			operator ref[-]element => {
				if (!ref.remove(element)) {
					throw "LinkedList: Element not found";
				}
				return ref;
			}
		};

		return this;
	};

	// See docs for LinkedList([0]).
	// Creates a linked list and populates it with initial values.
	//
	LinkedList += enumerable => {
		list = LinkedList();
		foreach (e in enumerable) {
			list.add(e);
		}
		return list;
	};


	// Stack implementation
	// A dynamic data structure which follows First In, Last Out (FILO) principle
	// dependencies:
	//	LinkedList
	//
	Stack = () => {
		
		__list = LinkedList();

		// Adds provided value to the top of the stack
		//
		push = (e) => {
			__list.insertAt(0, e);
		};

		// Removes and returns the top element of the stack
		//
		pop = () => {
			if (__list.length() == 0) {
				throw "Stack.pop: Stack empty";
			}
			return __list.removeAt(0);
		};

		// Returns the top value on the stack
		//
		peek = () => {
			if (__list.length() == 0) {
				throw "Stack.peek: Stack empty";
			}
			return __list.get(0);
		};

		// Returns true if there are no elements
		// present in the stack, otherwise false
		//
		isEmpty = () => __list.length() == 0;

		// Returns the element count of this stack
		//
		length = () => {
			return __list.length();
		};

		// Creates and returns an enumerator for this stack
		//
		enumerator = () => {
			return __list.enumerator();
		};

		// Returns the underlying enumerable 
		// that makes up this stack
		//
		toList = () => {
			return __list;
		};

		// The constructed stack
		//
		this = { 
			push = push,
			pop = pop,
			peek = peek,
			isEmpty = isEmpty,
			length = length,
			enumerator = enumerator,
			toList = toList,
			toString = () => __list.toString(this),

			// Pushes a new element to stack.
			// 	params:
			//			ref: Self reference
			//		element: Element to push
			//
			operator ref[+]element => {
				ref.push(element);
				return this;
			}
		};

		return this;
	};

	// See docs for Stack([0]).
	// Creates a stack and populates it with initial values.
	//
	Stack += enumerable => {
		stack = Stack();
		foreach (e in enumerable) {
			stack.push(e);
		}
		return stack;
	};


	// Queue implementation
	// A dynamic data structure which follows First In, First Out (FIFO) principle
	// dependencies:
	//	LinkedList
	//
	Queue = () => {

		__list = LinkedList();

		// Adds the provided element to the end of the queue 
		//
		enqueue = (e) => {
			__list.add(e);
		};

		// Removes and returns an element from the very beginning of the queue
		//
		dequeue = () => {
			if (__list.length() == 0) {
				throw "Queue.dequeue: Queue empty";
			}
			return __list.removeAt(0);
		};

		// Returns an element from the very beginning of the queue
		//
		peek = () => {
			if (__list.length() == 0) {
				throw "Queue.peek: Queue empty";
			}
			return __list.get(0);
		};

		// Returns true if there are no elements
		// present in the queue, otherwise false
		//
		isEmpty = () => __list.length() == 0;

		// Returns the element count of this queue
		//
		length = () => {
			return __list.length();
		};

		// Creates and returns an enumerator for this queue
		//
		enumerator = () => {
			return __list.enumerator();
		};

		// Returns the underlying enumerable
		// that makes up this queue
		toList = () => {
			return __list;
		};

		// The constructed queue
		this = {
			enqueue = enqueue,
			dequeue = dequeue,
			peek = peek,
			isEmpty = isEmpty,
			length = length,
			enumerator = enumerator,
			toList = toList,
			toString = () => __list.toString(this),

			// Enqueues a new element to queue
			// 	params:
			// 			ref: Self reference
			// 		element: Element to enqueue
			//
			operator ref[+]element => {
				ref.enqueue(element);
				return this;
			}
		};

		return this;
	};

	// See docs for Queue([0]).
	// Creates a queue and populates it with initial values.
	//
	Queue += enumerable => {
		queue = Queue();
		foreach (e in enumerable) {
			queue.enqueue(e);
		}
		return queue;
	};

	return {
		LinkedList = LinkedList,
		Stack = Stack,
		Queue = Queue
	};
};

// Export library
Collections = __COLLECTIONS_IMPL__();
