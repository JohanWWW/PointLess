
__STD_IMPL__ = () => {

    // Warning: Modifying native functions in this file is not recommended
    //          and may lead to inconsistent results.

    // Dictionary natives
    __dict_allocate = native () => <@"std.__dict_allocate">; // DEPRACTED: Use built in dictionary notation instead

    __dict_set = native (dictRef, key, value) => <@"std.__dict_set">; // DEPRECATED

    __dict_get = native (dictRef, key) => <@"std.__dict_get">; // DEPRECATED

    __dict_contains = native (dictRef, key) => <@"std.__dict_contains">; // DEPRECATED

    __dict_remove = native (dictRef, key) => <@"std.__dict_remove">; // DEPRECATED

    __dict_length = native (dictRef) => <@"std.__dict_length">; // DEPRECATED

    __dict_get_key_array = native (dictRef) => <@"std.__dict_get_key_array">; // DEPRECATED

    __dict_get_value_array = native (dictRef) => <@"std.__dict_get_value_array">; // DEPRECATED

    // Array natives
    __array_allocate = native (s) => <@"std.__array_allocate">; // DEPRECATED: Use built in array notation instead

    __array_length = native (ref) => <@"std.__array_length">; // DEPRECATED

    __array_get = native (ref, index) => <@"std.__array_get">; // DEPRECATED

    __array_set = native (ref, index, value) => <@"std.__array_set">; // DEPRECATED

    // String natives
    __string_array = native (s) => <@"std.String.__string_array">; // DEPRECATED: String literals now evaluate to objects

    // Type check natives
    __is_number = native (value) => <@"std.__is_number">;

    __is_integer = native (value) => <@"std.__is_integer">;

    __is_decimal = native (value) => <@"std.__is_decimal">;

    __is_string = native (value) => <@"std.__is_string">; // DEPRECATED: Use __is_string_object instead

    __is_string_object = native (value) => <@"std.__is_string_object">;

    __is_character = native (value) => <@"std.__is_character">;

    __is_bool = native (value) => <@"std.__is_bool">;

    __is_object = native (value) => <@"std.__is_object">;

    __is_method = native (value) => <@"std.__is_method">;


    //
    //
    print = native (obj) => <@"std.print">;

    //
    //
    println = native (obj) => <@"std.println">;

    println += () => println("");

    setCursorPosition = native (x, y) => <@"std.setCursorPosition">;

    setCursorVisibility = native (visible) => <@"std.setCursorVisibility">;

    setBackgroundColor = native (color) => <@"std.setBackgroundColor">;

    //
    //
    readln = native () => <@"std.readln">;

    //
    //
    number = native (s) => <@"std.number">; // DEPRECATED

    //
    //
    delay = native (millis) => <@"std.delay">;

    //
    // Returns milliseconds elapsed since system start
    //
    systemMillis = native () => <@"std.systemMillis">;

    //
    // Returns ticks elapsed since system start
    //
    systemTicks = () => {
        return systemMillis() * 10000;
    };

    //
    // Returns elapsed time since 0001-01-01 00:00:00 in ticks.
    // 1 tick = 100 nanoseconds
    //
    ticks = native () => <@"std.ticks">;

    //
    // Returns elapsed time since the beginning of unix time (1970-01-01 00:00:00) in ticks.
    // 1 tick = 100 nanoseconds
    //
    ticksUnix = () => {
        return ticks() - __ticksUntilUnixStart__;
    };

    Console = {
        print = print,
        println = println,
        readln = readln,
        setCursorPosition = setCursorPosition,
        setCursorVisibility = setCursorVisibility,
        setBackgroundColor = setBackgroundColor,
        Color = {
            BLACK = 0,
            DARK_BLUE = 1,
            DARK_GREEN = 2,
            DARK_CYAN = 3,
            DARK_RED = 4,
            DARK_MAGENTA = 5,
            DARK_YELLOW = 6,
            GRAY = 7,
            DARK_GRAY = 8,
            BLUE = 9,
            GREEN = 10,
            CYAN = 11,
            RED = 12,
            MAGENTA = 13,
            YELLOW = 14,
            WHITE = 15
        }
    };

    Arrays = {

        //
        // Allocates storage for a new array and populates it 
        // with the elements from the input enumerable
        //
        from = enumerable => {
            length = enumerable.length();
            array = alloc [length];
            i = 0;
            foreach (e in enumerable) {
                array[i] = e;
                i += 1;
            }
            return array;
        },

        //
        // Allocates storage for a new array
        //
        allocate =  
                    //
                    // Parameters:
                    //  size: The size of the array
                    //
                    (size => alloc [size]) 
                    +

                    //
                    // Parameters:
                    //  size: The size of the array
                    //  generator: A provider that returns an initial value to populate the array with
                    //
                    ((size, generator) => {
                        array = Arrays.allocate(size);
                        i = 0;
                        while (i < size) {
                            array.set(i, generator());
                            i += 1;
                        }
                        return array;
                    }),

        //
        // Allocates storage for new array with zero index positions
        //
        empty = () => alloc [0]
    };

    //
    // Dynamically sized data structure that uses arrays internally.
    // Creates a list with initial values and initial capacity.
    //       enumerable: An initial enumerable used to populate the list
    //  initialCapacity: Initial capacity of this list. Must be greater than
    //                   or equal to the size of the enumerable
    //
    ArrayList = (enumerable, initialCapacity) => {

        initArray = () => {
            len = enumerable.length();
            if (initialCapacity < len) {
                throw "Initial capacity cannot be set to a value less than the length of the initial enumerable";
            }
            a = alloc [initialCapacity];
            if (len > 0) {
                i = 0;
                foreach (e in enumerable) {
                    a[i] = e;
                    i += 1;
                }
            }
            return a;
        };

        // Init        
        _size = enumerable.length();
        _array = initArray();

        // ======================================

        //
        // Adds an element to the end of the list
        //
        add = e => {
            ensureCapacity(_size + 1);
            _array[_size] = e;
            _size += 1;
        };

        //
        // Removes element if it is present in the list and is strictly equal to the provided value.
        // Returns true if the element was found and remove otherwise false.
        //  e: The element to remove
        //
        remove = e => {
            found = false;
            i = 0;
            while (i < _size && !found) {
                if (_array[i] === e) {
                    found = true;
                }
                else {
                    i += 1;
                }
            }
            if (found) {
                removeAt(i);
            }
            return found;
        };

        //
        // Removes element at the specified index
        //
        removeAt = index => {
            if (isIndexOutOfRange(index)) {
                throw "Argument out of range";
            }
            removedElement = _array[index];
            if (index == _size - 1) {
                _array[index] = void;
            }
            else {
                i = index;
                while (i < _size) {
                    _array[i] = _array[i + 1];
                    i += 1;
                }
            }
            _size -= 1;
            return removedElement;
        };


        //
        // Inserts value at the specified index
        //
        insertAt = (index, e) => {
            if (index < 0 || index > _size) {
                throw "Argument out of range";
            }
            ensureCapacity(_size + 1);
            if (index == _size) {
                tmp = _array[index];
                _array[index] = e;
                _array[index + 1] = tmp;
            }
            else {
                i = _size;
                while (i > index) {
                    _array[i] = _array[i - 1];
                    i -= 1;
                }
                _array[index] = e;
            }
            _size += 1;
        };

        //
        // Overwrites a value at specified index
        //
        set = (index, e) => {
            if (isIndexOutOfRange(index)) {
                throw "Argument out of range";
            }
            _array[index] = e;
        };

        //
        // Returns element at specified index
        //
        get = index => {
            if (isIndexOutOfRange(index)) {
                throw "Argument out of range";
            }
            return _array[index];
        };

        //
        // Returns true if list contains a value that is strictly equal to the specified value
        // otherwise return false
        //
        contains = e => {
            found = false;
            arrEn = _array.enumerator();
            while (arrEn.next() && !found) {
                if (e === arrEn.current()) {
                    found = true;
                }
            }
            return found;
        };

        //
        // Returns true if the list is empty otherwise return false
        //
        isEmpty = () => _size == 0;

        //
        // Returns an enumerator object for this list
        //
        enumerator = () => {
            i = -1;
            return {
                next = () => {
                    hasNext = i + 1 < _size;
                    if (hasNext) {
                        i += 1;
                    }
                    return hasNext;
                },

                current = () => _array[i],

                dispose = () => { }
            };
        };

        //
        // Creates and returns an array with the list elements
        //
        toArray = () => {
            a = alloc [_size];
            copyArray(_array, a, _size);
            return a;
        };

        //
        // Returns the string representation of this list
        //
        toString = () => {
            i = 0;
            sb = "[";
            while (i < _size) {
                e = _array[i];
                if (e === this) {
                    sb += "<this list>";
                }
                else if (__is_string_object(e)) {
                    sb += "\"" + __escapeSpecialChars__(e) + "\"";
                }
                else if (__is_character(e)) {
                    sb += "'" + __escapeSpecialChars__(e) + "'";
                }
                else {
                    sb += "" + e;
                }
                if (i != _size - 1) {
                    sb += ",";
                }
                i += 1;
            }
            sb += "]";
            return sb;
        };

        isIndexOutOfRange = index => index < 0 || index >= _size;

        //
        // Ensures that the array size is greater than or equal the provided argument.
        // If the array size is smaller than the argument a new array is allocated
        // and the elements from the previous array are transfered to the new one.
        // The size of the new array might be larger than the argument.
        //  min: The minimum size requirement that the array must meet
        //
        ensureCapacity = min => {
            if (_array.length() < min) {
                newSize = _array.length() * 2;
                if (newSize < min) {
                    newSize = min;
                }
                resizeArray(newSize);
            }
        };

        //
        // Resizes array by allocating a new array with the specified size.
        // The element of the previous array are copied to the new one.
        // Does nothing if the array size is equal to the specified size.
        // This operation truncates an array which can lead to potential data loss. Handle with care!
        //
        resizeArray = size => {
            if (size > _array.length()) {
                newArray = alloc [size];
                copyArray(_array, newArray);
                _array = newArray;
            }
            else if (size < _array.length()) {
                newArray = alloc [size];
                copyArray(_array, newArray, size);
                _array = newArray;
            }
        };

        copyArray = (src, dst) => {
            i = 0;
            while (i < src.length()) {
                dst[i] = src[i];
                i += 1;
            }
        };

        copyArray += (src, dst, count) => {
            i = 0;
            while (i < count) {
                dst[i] = src[i];
                i += 1;
            }
        };

        //
        // Returns the capacity of this list
        //
        capacity = () => _array.length();

        //
        // Sets the capacity of this list.
        // This operation allocates a new array with the specified size but keeping
        // all the elements from the old array.
        //  c: The new capacity 
        //
        capacity += c => {
            if (c < _size) {
                throw "Cannot set capacity to a value smaller than list length";
            }
            // Resize if needed
            resizeArray(c);
        };

        this = {
            length = () => _size,
            capacity = capacity,
            add = add,
            remove = remove,
            removeAt = removeAt,
            insertAt = insertAt,
            get = get,
            set = set,
            contains = contains,
            isEmpty = isEmpty,
            enumerator = enumerator,
            toArray = toArray,
            toString = toString,

            //
            // See docs for get
            //
            indexer [index] => get(index),

            //
            // See docs for set
            //
            indexer [index] <- value => {
                set(index, value);
            },

            //
            // See docs for add.
            // Designed to be used with the += operator.
            //
            operator _ [+] e => {
                add(e);
                return this;
            },

            //
            // Removes the specified value from the list.
            // Throws exception if the value was not found.
            // Designed to be used with the -= operator.
            //  value: The value to remove from the list
            //
            operator _ [-] value => {
                if (!remove(value)) {
                    throw "Element is not present in the list";
                }
                return this;
            }
        };

        return this;
    };

    //
    // See docs for ArrayList([2]).
    // Creates a list with initial capacity 4 if the provided enumerable is empty
    // otherwise the list capacity is twice the size of the enumerable.
    //
    ArrayList += enumerable => 
        ArrayList(enumerable, enumerable.length() == 0 ? 4 : enumerable.length() * 2);

    //
    // See docs for ArrayList([1]).
    // Creates an empty list with capacity 4.
    //
    ArrayList += () => ArrayList(alloc [0]);

    // Not recommended for regular math operations
    __intPow__ = (x, y) => {
        if (y < 0) {
            throw "std.__intPow__: Exponent was less than zero";
        }
        p = 1;
        i = y;
        while (i > 0) {
            p *= x;
            i -= 1;
        }
        return p;
    };

    __parseInt__ = (s) => {
        s = s.getChars();
        sum = 0;
        signum = 1;
        e = s.length() - 1;
        i = 0;
        if (s[0] == __minusSign__) {
            signum = -1;
            e -= 1;
            i += 1;
        }
        while (i < s.length()) {
            d = s[i];
            if (__charToDigit__.contains(d)) {
                    sum += __charToDigit__[d] * __intPow__(10, e);
            }
            else {
                throw "Found illegal character '" + d + "' at index " + i + " when parsing input string";
            }
            i += 1;
            e -= 1;
        }

        return signum * sum;
    };

    // TODO: Maybe it should parse string as int and shift decimal point instead?
    __parseDecimal__ = (s) => {
        i = 0;
        dotSignCount = 0;
        foreach (c in s) {
            if (c == __dotSign__) {
                dotSignCount += 1;
            }
            i += 1;
        }

        if (dotSignCount > 1) {
            throw "std.Convert.string.toDecimal: Illegal number format";
        }

        sum = .0;
        hasDecimalPoint = (dotSignCount == 1);

        if (hasDecimalPoint) {
            segments = s.split(__dotSign__);

            integers = segments[0];
            decimals = segments[1];

            signum = 1;
            if (integers.length() > 0) {
                if (integers[0] == __minusSign__) {
                    signum = -1;
                    if (integers.length() > 1) {
                        sum += __parseInt__(integers.substring(1, integers.length()));
                    }
                }
                else {
                    sum += __parseInt__(integers);
                }
            }

            decimalSum = .0;
            e = 0;
            while (e < decimals.length()) {
                d = decimals[e];
                if (__charToDigit__.contains(d)) {
                    decimalSum += __charToDigit__[d] / (__intPow__(10, e) + .0);
                }
                else {
                    throw "Found illegal character '" + d + "' at index " + (integers.length() + e + 1) + " when parsing input string";
                }
                e += 1;
            }

            sum += decimalSum / 10;
            sum *= signum;
        }
        else {
            sum += __parseInt__(s);
        }

        return sum;
    };

    __escapeSpecialChars__ = s => {
        if (__is_character(s)) {
            s = "" + s;
        }
        s = s.replaceAll("\\", "\\\\");
        s = s.replaceAll("\"", "\\\"");
        s = s.replaceAll("\n", "\\n");
        s = s.replaceAll("\t", "\\t");
        return s.toString();
    };

    // 0001-00-00 00:00:00 --> 1970-01-01 00:00:00
    __ticksUntilUnixStart__ = 621355968000000000;

    // 0-9
    __digits__ = "0123456789";

    __charToDigit__ = {
        ['0'] = 0,
        ['1'] = 1,
        ['2'] = 2,
        ['3'] = 3,
        ['4'] = 4,
        ['5'] = 5,
        ['6'] = 6,
        ['7'] = 7,
        ['8'] = 8,
        ['9'] = 9
    };

    __minusSign__ = '-';
    __plusSign__ = '+';
    __dotSign__ = '.';
    __commaSign__ = ',';
    __emptyString__ = "";

    return {
        isNumber = __is_number,
        isInteger = __is_integer,
        isDecimal = __is_decimal,
        isString = __is_string,
        isStringObject = __is_string_object,
        isBool = __is_bool,
        isObject = __is_object,
        isMethod = __is_method,

        parseInt = __parseInt__,
        parseDecimal = __parseDecimal__,

        delay = delay,
        systemMillis = systemMillis,
        systemTicks = systemTicks,
        ticks = ticks,
        ticksUnix = ticksUnix,
        Console = Console,
        Arrays = Arrays,

        ArrayList = ArrayList,

        escapeSpecialCharacters = __escapeSpecialChars__
    };
};

std = __STD_IMPL__();
